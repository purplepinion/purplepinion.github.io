<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[链表中倒数k个节点]]></title>
    <url>%2F2019%2F04%2F02%2F%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0k%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[链表中倒数k个节点题目描述 输入一个链表，输出该链表中倒数第k个结点。 12345678910111213141516171819202122232425262728293031/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; //1.输入空指针 //2.节点总数少于K //3.k = 0时，k - 1 为0xFFFFFFFF if(head==null || k==0)//输入空指针返回 return null; ListNode pa = head;//两个指针 ListNode pb = head; for(int i=0;i&lt;k-1;++i)&#123;//a指针先走k-1 if(pa.next!=null) pa = pa.next; else return null;//节点总数少于K &#125; while(pa.next!=null)&#123;//同时走到a指针为空 pa = pa.next; pb = pb.next; &#125; return pb;//返回b指针 &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符流中第一个不重复的元素]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[字符流中第一个不重复的元素题目描述 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 输出描述: 如果当前字符流没有存在出现一次的字符，返回#字符。1234567891011121314151617181920212223import java.util.HashMap;import java.util.ArrayList;public class Solution &#123; HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;();//记录字符和出现次数 ArrayList&lt;Character&gt; list = new ArrayList&lt;&gt;();//记录字符顺序 //Insert one char from stringstream public void Insert(char ch) &#123; if(map.containsKey(ch))//字符出现过，计数加1 map.put(ch,map.get(ch)+1); else map.put(ch,1);//字符没出现过，计数为1 list.add(ch); &#125; //return the first appearence once char in current stringstream public char FirstAppearingOnce() &#123; for(Character c:list)//按顺序遍历找到第一个出现次数是1的字符 if(map.get(c)==1) return c; return '#'; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复杂链表的复制]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[复杂链表的复制题目描述 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）12345678910111213141516171819202122232425262728293031/*public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125;*/import java.util.HashMap;public class Solution &#123; public RandomListNode Clone(RandomListNode pHead) &#123; HashMap&lt;RandomListNode,RandomListNode&gt; map = new HashMap&lt;&gt;();//存放节点，查找O(1) RandomListNode p = pHead; while(p!=null)&#123;//遍历第一次，将值赋给新节点 map.put(p,new RandomListNode(p.label)); p = p.next; &#125; p = pHead; while(p!=null)&#123;//遍历第二次将，next，和random赋值给新的节点 map.get(p).next = map.get(p.next); map.get(p).random = map.get(p.random); p = p.next; &#125; return map.get(pHead); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除链表中重复节点]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[删除链表中重复节点题目描述 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 1234567891011121314151617181920212223242526272829303132333435/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode deleteDuplication(ListNode pHead) &#123; if(pHead==null)//空链表返回空 return null; ListNode firstNode = new ListNode(-1);//防止头节点被删除 firstNode.next = pHead; ListNode p = pHead; ListNode pre = firstNode;//保存上一个节点 while(p!=null&amp;&amp;p.next!=null)&#123;//当前节点和下一个节点不为空 if(p.val==p.next.val)&#123;//当前节点和下一个节点重复 int val = p.val; while(p!=null&amp;&amp;p.val==val)&#123;//跳过所有重复的节点 p = p.next; &#125; pre.next = p;//pre指向新的值节点 &#125; else&#123;//当前节点和下一个节点不重复，p和pre向后移动 pre = p; p = p.next; &#125; &#125; return firstNode.next;//返回结果 &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表中环的入口]]></title>
    <url>%2F2019%2F04%2F02%2F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[链表中环的入口题目描述 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode EntryNodeOfLoop(ListNode pHead) &#123; if(pHead==null || pHead.next==null)//此时链表无环 return null; ListNode pSlow = pHead.next; ListNode pFast = pHead; ListNode meet = null; while(pFast!=null&amp;&amp;pSlow!=null)&#123;//检测链表是否存在环 if(pFast==pSlow)&#123; meet = pSlow; break; &#125; pSlow = pSlow.next; pFast = pFast.next; if(pFast.next!=null)&#123; pFast = pFast.next; &#125; &#125; if(meet==null)//链表不存在环 return null; int nodeCount = 1;//链表存在环，计数 ListNode pNode = meet; while(pNode.next!=meet)&#123; pNode=pNode.next; nodeCount++;//获得环中节点数 &#125; pFast = pHead; for(int i=0;i&lt;nodeCount;++i)//指针1先走nodeCount步 pFast = pFast.next; pSlow = pHead;//指针2从头开始 while(pFast!=pSlow)&#123;//指针1 2 同时走，相等即环入口 pFast = pFast.next; pSlow = pSlow.next; &#125; return pFast; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven管理工具]]></title>
    <url>%2F2019%2F04%2F01%2Fmaven001%2F</url>
    <content type="text"><![CDATA[Maven管理工具1.Maven简介 Apache下开源项目，java开发，管理java项目 Maven项目体积小，没有jar包，jar包与项目分离 jar包放在本地仓库，需要jar包，通过公司组织-项目-版本获取 本地仓库索引提高效率 依赖管理概念 多个项目依赖一个仓库里的jar包 项目构建：编码-&gt;编译-&gt;测试(junit)-&gt;运行-&gt;打包-&gt;部署 项目一键构建概念 脱离Tomcat，eclipse运行( 编译到部署) mvn tomcat:run 2.Maven好处 依赖管理 对jar包统一管理，节省空间 一件构建 跨平台 大型项目，提高开发效率 Maven分模块开发 项目分层 互联网项目 按业务分 传统项目 按层分 entity dao service web 3.Maven安装 目录结构 bin 命令 mvn mvnDebug boot 类加载器 conf 配置文件 settings.xml 核心文件 lib 库 jar包 配置 环境变量配置 jdk Maven3.3.x 需要jdk17.以上 版本 环境变量配置 Maven 新建MAVEN_HOME F:\workspace\Maven\apache-maven-3.3.9 添加%MAVEN_HOME %\bin 到path 测试命令 mvn -v 配置本地仓库 修改settings.xml F:\workspace\Maven\repository 本地仓库-&gt;远程仓库(私服)-&gt;中央仓库4.Maven目录结构 src mian 主目录 java java代码 resources 配置文件 properties xml webapp test 测试目录 java java代码 junit测试 resources junit测试配置文件 默认为空 从main读取 webapp pom.xml 项目核心文件5.Maven命令 mvn Tomcat:run 一键启动mvn clean 清理构建信息mvn compile 编译主目录文件mvn test 编译运行test目录代码mvn package 打包web项目，放在target目录mvn install 项目发布到本地仓库 war包mvn site 对项目说明mvn deploy 发布到私服 Maven生命周期 Clean生命周期 clean Default生命周期 compile-&gt;test-&gt;package-&gt;install site生命周期 site 不同生命周期可以同时执行 mvn clean package 7.项目构建 me2插件安装 选择Maven版本 设置settings文件 新建Maven项目 跳过骨架选择(模板) java webapp Group Id ：组名称 Artfact Id：项目名称 Version：版本 packaging：打包方式 webapp下创建WEB-INF添加WEB.xml pom.xml下添加配置文件]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP和Tomcat服务器]]></title>
    <url>%2F2019%2F04%2F01%2Ftomcat001%2F</url>
    <content type="text"><![CDATA[HTTP和Tomcat服务器导入 服务端分层 web层 jsp+servlet struct2 springMVC service层 spring dao层 jdbc DBUtil hibernate mybatis HTTP协议分析 版本区别 HTTP/1.0，发送请求，创建一次连接，获得一个web资源，断开连接 HTTP/1.1，发送请求，创建一次连接，获得多个web资源，保持连接 HTTP请求 请求行：method URI protocol 请求头：格式：key：value 请求体：post提交方式参数 HTTP响应 响应行：protocol statusDode statusDescription 响应头：格式：key：value 响应体：请求资源正文 状态码 200：一切正常 ok302：重定向304：拿本地缓存 Not Modify404：服务器没有资源 Not Found500：服务器端错误 WEB开发常见概念 B/S系统和C/S系统 Browser/Server：浏览器 客户端系统 Client/Server：客户端 服务器系统 Web应用服务器 供向外部发布web资源的服务器软件 web资源 存在于web应用服务器可供外界访问的资源就是web资源 静态资源：web页面中始终不变的数据 HTML、CSS、JS、图片、多媒体 动态资源：web页面中由程序产生的数据，不同时间访问的数据不同（Java代码生成的资源） JSP/Servlet、ASP、PHP WEB开发常见Web应用服务器 weblogic：Oracle下大型收费Web服务器 支持全部JavaEE规范 websphere：IBM下大型收费Web服务器 支持全部JavaEE规范 Tomcat：Apache下中小型开源Web服务器 支持部分JavaEE规范（servlet 和 jsp规范） Tomcat的目录结构 bin 脚本目录 startup conf 配置目录 server.xml 核心配置文件 lib jar包，类库 logs 日志 temp 临时目录 webapps 应用发布目录* work Tomcat处理JSP的工作目录 Tomcat启动和关闭 bin目录下startup.bat 启动 bin目录下shutdown.bat 启动 启动不成功 没有配置JAVA_HOME环境变量 端口冲突 解决方法1 cmd 下netstat -aov 查看所有端口使用情况任务管理器pid结束进程 解决方法2 conf目录下修改server.xml文件&lt;Connector port=”8080” protocol=”HTTP/1.1”connectionTimeout=”20000”redirectPort=”8443” /&gt;80 HTTP协议默认端口 Web应用目录结构 mail html、jsp、css、js文件 WEB-INF目录 （受保护目录，外部不能访问） classes目录（java类） lib （java 类运行所需的jar包） web.xml文件 （web应用的配置文件）核心配置文件 eclipse和Tomcat绑定 Windows-&gt;preferences-&gt;server 添加Apache7.0 Tomcat Tomcat 配置 new一个服务器 双击服务器修改 server location use Tomcat installation deploy path webapps web服务发布 发布服务（web项目） 方法一 右键服务器-&gt;addAndRemove-&gt;add-&gt;finish 方法二 右键项目-&gt;runAsServer 发布过程 将web项目下的 webContent内容放入Tomcat下webapps目录下 项目名称和服务器项目是映射关系，可能不同，在web project settings设置 发布项目后server.xml有记录，本地删除后要手动修改 web服务响应 Java Resources/src/packagename/classname 123456789public class MyFirstServlet implements Servlet&#123;@Overridepublic void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; // 想客户端提供响应方法 HttpServletResponse response = (HttpServletResponse) res; response.getWriter().write("This is my webapp");&#125;&#125; webContent/WEB-INF/lib/web.xml 12345678910 &lt;display-name&gt;WEB12&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;MyFirstServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.chris.servlet.MyFirstServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;MyFirstServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/abc&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt;]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb核心Servlet]]></title>
    <url>%2F2019%2F04%2F01%2Fservlet001%2F</url>
    <content type="text"><![CDATA[JavaWeb核心Servlet1.Servlet简介Servlet 运行在服务端的Java小程序，是sun公司提供一套规范（接口），用来处理客户端请求、响应给浏览器的动态资源。但servlet的实质就是java代码，通过java的API动态的向客户端输出内容 servlet规范：包含三个技术点（API） servlet技术 filter技术—过滤器 listener技术—监听器 实现步骤： 创建类实现Servlet接口 覆盖尚未实现的方法—service方法 在web.xml进行servlet的配置 但在实际开发中，我们不会直接去实现Servlet接口，因为那样需要覆盖的方法太多，我们一般创建类继承HttpServlet 实际实现步骤： 创建类继承HttpServlet类 覆盖doGet和doPost 在web.xml中进行servlet的配置 2.Servlet的API（生命周期） Servlet接口中方法 init(ServletConfig config) 何时执行：servlet对象创建的时候执行 ServletConfig ： 代表的是该servlet对象的配置信息 service（ServletRequest request,ServletResponse response） 何时执行：每次请求都会执行 ServletRequest ：代表请求 认为ServletRequest 内部封装的是http请求的信息 ServletResponse ：代表响应 认为要封装的是响应的信息 HttpServlet类的方法 init() doGet(HttpServletRequest request,HttpServletResponse response) doPost(HttpServletRequest request,HttpServletResponse response) destroy() Servlet的生命周期 Servlet何时创建默认第一次访问servlet时创建该对象 Servlet何时销毁服务器关闭servlet就销毁了 每次访问必然执行的方法service(ServletRequest req, ServletResponse res)方法 3.Servlet的配置 基本配置 123456789&lt;servlet&gt; &lt;servlet-name&gt;MyFirstServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.chris.servlet.QuickStartServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;MyFirstServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/quickStartServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; url-pattern配置方式： 1.完全匹配 访问的资源与配置的资源完全相同才能访问到 /quickStartServlet 2.目录匹配 格式：/虚拟的目录../ 代表任意 /aaa/bbb/ccc 3.扩展名匹配 格式：*.扩展名 /.abcd第二种与第三种不要混用 /aaa/bbb/.abcd（错误的） 服务器启动实例化Servlet配置 Servlet的何时创建：默认第一次访问时创建 为什么是默认？当在servlet的配置时 加上一个配置 servlet对象在服务器启动时就创建 5 //数字优先级 缺省Servlet 可以将url-pattern配置一个/，代表该servlet是缺省的servlet 什么是缺省的servlet？当你访问资源地址所有的servlet都不匹配时 ， 缺省的servlet负责处理其实，web应用中所有的资源的响应都是servlet负责，包括静态资源 欢迎页面 12345678&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; 4.ServletContext对象 ServletContext对象 ServletContext代表是一个web应用的环境（上下文）对象，ServletContext对象内部封装是该web应用的信息， ServletContext对象一个web应用只有一个 一个web应用有几个servlet对象？—-多个 ServletContext对象的生命周期 创建：该web应用被加载（服务器启动或发布web应用（前提，服务器启动状态）） 销毁：web应用被卸载（服务器关闭，移除该web应用） 怎样获得ServletContext对象 ServletContext servletContext = config.getServletContext(); ServletContext servletContext = this.getServletContext(); ServletContext的作用 获得web应用全局的初始化参数web.xml中配置初始化参数 1234&lt;context-param&gt;&lt;param-name&gt;driver&lt;/param-name&gt;&lt;param-value&gt;com.mysql.jdbc.Driver&lt;/param-value&gt;&lt;/context-param&gt; 通过context对象获得参数 12345678910111213141516171819 //获得ServletContext对象 ServletContext context = getServletContext(); //1、获得初始化参数 String initParameter = context.getInitParameter("driver"); System.out.println(initParameter); //2、获得a b c d.txt的绝对路径//2.1 获得a.txtString realPath_A = context.getRealPath("a.txt");System.out.println(realPath_A);//2.2 获得b.txtString realPath_B = context.getRealPath("WEB-INF/b.txt");System.out.println(realPath_B);//2.3 获得c.txtString realPath_C = context.getRealPath("WEB-INF/classes/c.txt");System.out.println(realPath_C);//2.4 获得d.txt----获取不到//在读取src(classes) 下的资源是可以同类加载器----专门加载classes 下的文件的//getResource() 参数是一个相对地址 相对classesString path = ContextServlet.class.getClassLoader().getResource("c.txt").getPath(); 获得web应用中任何资源的绝对路径（重要） 方法：String path = context.getRealPath(相对于该web应用的相对地址); ServletContext是一个域对象（重要） 什么是域对象？什么是域？ 存储数据的区域就是域对象ServletContext域对象的作用范围：整个web应（所有的web资源都可以随意向 &gt;servletcontext域中存取数据，数据可以共享） 域对象的通用的方法： setAtrribute(String name,Object obj);getAttribute(String name);removeAttribute(String name);]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode:three_sum]]></title>
    <url>%2F2019%2F03%2F30%2Fleetcode-3sum%2F</url>
    <content type="text"><![CDATA[three sumGiven an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c) The solution set must not contain duplicate triplets. $$For example, given array S = {-1 0 1 2 -1 -4}, ​ A solution set is:​ (-1, 0, 1)​ (-1, -1, 2)​​ $$ 12345678910111213141516171819202122232425262728293031323334353637import java.util.Arrays;import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(int[] num) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; allres = new ArrayList&lt;&gt;(); int N = num.length; int l,h,target; int sum,count = 0; Arrays.sort(num); for(int i=0;i&lt;N-2;++i)&#123; target = -num[i]; l = i + 1; h = N - 1; if(i&gt;0&amp;&amp;num[i]==num[i-1]) continue; while(l&lt;h)&#123; sum = num[l] + num[h]; if(target==sum) &#123; ++count; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(num[i]); list.add(num[l]); list.add(num[h]); allres.add(list); while(l&lt;h&amp;&amp;num[l]==num[l+1]) ++l; while(l&lt;h&amp;&amp;num[h]==num[h-1]) --h; ++l; --h; &#125; else if(sum&lt;target) ++l; else --h; &#125; &#125; return allres; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM运行时数据区]]></title>
    <url>%2F2019%2F03%2F22%2Fjvm001%2F</url>
    <content type="text"><![CDATA[JVM运行时数据区 程序计数器 定义 当前线程所执行的字节码的行号指示器 作用 改变程序计数器的值，实现分支，循环，跳转，异常处理，线程恢复 注意 每条线程都有自己的程序计数器 线程执行JAVA方法时，程序计数器的值是当前正在执行的虚拟机字节码指令的地址 线程执行native方法时，程序计数器的值为空（undefined） JVM虚拟机栈 定义 存储当前线程运行方法所需要的数据、指令和返回地址，生命周期与线程相同，同样属于线程私有区域。 每个 Java 方法在执行的同时都会创建一个栈帧用于存储局部变量、操作数栈、方法出口等信息 栈帧 + 局部变量表 + 操作数栈 + 动态链接 + 出口 作用 局部变量表存放编译前可知的数据，boolean byte char short int float long double reference, 64bit 的long double占两个Slot。 注意局部变量表所需的内存空间在编译期间就会车队分配完成，因为在进入一个方法时，这个方法需要在栈帧中分配多大的局部空间是完全确定的，方法运行期间局部变量大小是不会改变的。StackOverflowError: 线程请求深度大于虚拟机允许深度 OutOfMemoryError: 虚拟机栈扩展无法申请到足够内存 本地方法栈 定义 和虚拟机栈类似，只不过他存储的是当前线程调用的本地方法所需要的数据、指令和返回地址等，本地方法时标识有 Native 关键字的方法 注意 有些虚拟机（如 Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一了。 JAVA堆 定义 属于线程共享区域，在虚拟机启动时创建，是虚拟机管理的内存中最大的一块。它的唯一作用就是存放对象实例。 作用 根据虚拟机规范的描述是：所有的对象实例及数组都要在堆上分配。当然随着现在技术的发展优化这个也变得没有那么绝对,这块区域也是垃圾收集器管理的主要区域，现如今流行的垃圾回收器基本都采用的是分代收集算法，所以也就衍生了一些分代方式. 注意 JDK 1.8 以后 有了 Meta Space，其设计的目的在于规避永久代溢出的问题，因为 Meta Space 是可以自动扩容的，就跟 Java 中的集合一样。 方法区 定义 这块区域属于线程共享群与，主要存储的信息包括已被虚拟机你加载的类信息（类的元信息）、常量、静态变量、JIT（编译器编译后的代码）等数据。 运行时常量池 定义 方法区有一块区域我们称之为 运行时常量池，存放编译期生成的各种字面量和符号引用，运行时常量池有一个重要特征是具备动态性，也就是说在运行期间依然可以将新的常量放入池中，我们开发常用的有 String 类的 intern() 方法 直接内存 定义 JDK1.4后，新加入NIO类，是一种基于通道（channel)和缓冲区的I/O方式，直接调用native函数分配堆外内存，然后通过JAVA的DirectByteBuffer类作为堆外内存引用操作，避免JAVA堆和native堆来回复制数据]]></content>
      <categories>
        <category>JVM笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开通博客啦]]></title>
    <url>%2F2019%2F03%2F22%2Findex%2F</url>
    <content type="text"><![CDATA[#开通博客啦一眨眼都已经大学时光已经快要过完了，搭个小博客，记录一下平时的生活感悟，也发发技术小文章啦，欢迎来交流！]]></content>
      <categories>
        <category>相关</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
