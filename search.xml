<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM运行时数据区]]></title>
    <url>%2F2019%2F03%2F22%2Fjvm001%2F</url>
    <content type="text"><![CDATA[JVM运行时数据区​ 程序计数器 定义 当前线程所执行的字节码的行号指示器 作用 改变程序计数器的值，实现分支，循环，跳转，异常处理，线程恢复 注意 每条线程都有自己的程序计数器 线程执行JAVA方法时，程序计数器的值是当前正在执行的虚拟机字节码指令的地址 线程执行native方法时，程序计数器的值为空（undefined） JVM虚拟机栈 定义 存储当前线程运行方法所需要的数据、指令和返回地址，生命周期与线程相同，同样属于线程私有区域。 每个 Java 方法在执行的同时都会创建一个栈帧用于存储局部变量、操作数栈、方法出口等信息 栈帧 + 局部变量表 + 操作数栈 + 动态链接 + 出口 作用 局部变量表存放编译前可知的数据，boolean byte char short int float long double reference, 64bit 的long double占两个Slot。 注意局部变量表所需的内存空间在编译期间就会车队分配完成，因为在进入一个方法时，这个方法需要在栈帧中分配多大的局部空间是完全确定的，方法运行期间局部变量大小是不会改变的。StackOverflowError: 线程请求深度大于虚拟机允许深度 OutOfMemoryError: 虚拟机栈扩展无法申请到足够内存 本地方法栈 定义 和虚拟机栈类似，只不过他存储的是当前线程调用的本地方法所需要的数据、指令和返回地址等，本地方法时标识有 Native 关键字的方法 注意 有些虚拟机（如 Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一了。 JAVA堆 定义 属于线程共享区域，在虚拟机启动时创建，是虚拟机管理的内存中最大的一块。它的唯一作用就是存放对象实例。 作用 根据虚拟机规范的描述是：所有的对象实例及数组都要在堆上分配。当然随着现在技术的发展优化这个也变得没有那么绝对,这块区域也是垃圾收集器管理的主要区域，现如今流行的垃圾回收器基本都采用的是分代收集算法，所以也就衍生了一些分代方式. 注意 JDK 1.8 以后 有了 Meta Space，其设计的目的在于规避永久代溢出的问题，因为 Meta Space 是可以自动扩容的，就跟 Java 中的集合一样。 方法区 定义 这块区域属于线程共享群与，主要存储的信息包括已被虚拟机你加载的类信息（类的元信息）、常量、静态变量、JIT（编译器编译后的代码）等数据。 运行时常量池 定义 这方法区有一块区域我们称之为 运行时常量池，存放编译期生成的各种字面量和符号引用，运行时常量池有一个重要特征是具备动态性，也就是说在运行期间依然可以将新的常量放入池中，我们开发常用的有 String 类的 intern() 方法 直接内存 定义 JDK1.4后，新加入NIO类，是一种基于通道（channel)和缓冲区的I/O方式，直接调用native函数分配堆外内存，然后通过JAVA的DirectByteBuffer类作为堆外内存引用操作，避免JAVA堆和native堆来回复制数据]]></content>
      <categories>
        <category>JVM笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开通博客啦]]></title>
    <url>%2F2019%2F03%2F22%2Findex%2F</url>
    <content type="text"><![CDATA[#开通博客啦一眨眼都已经大学时光已经快要过完了，搭个小博客，记录一下平时的生活感悟，也发发技术小文章啦，欢迎来交流！]]></content>
      <categories>
        <category>相关</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
